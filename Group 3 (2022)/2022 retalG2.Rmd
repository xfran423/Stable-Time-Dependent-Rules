---
title: "2022 RetalG2"
author: "Xavier Francis"
date: '2023-08-29'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


#Load packages
```{r}
library(readr)
library(dplyr)
library(tidyr)
library(data.table) 
library(ggplot2)
library(chemodiv)
library(introdataviz)
library(lme4)
library(multcomp)
library(sjPlot)
library(emdist)


```


#Data cleaning chunk 1. Here and in the next several data cleaning chunks we are getting rid of duplicate observations, unknown behaviors, and dealing with undirected behaviors
``` {r}
#group 2

matrix.please<-function(x) {
  m<-as.matrix(x[,-1])
  rownames(m)<-x[,1]
  m
}

setwd("C:/Users/Xmanf/Desktop/Ch1 TDR files")
getwd()

`2022_birdIDsG2` <- read_csv("2022_birdIDs.csv")


`2022_interactions_rawG2` <- read_csv("2022_interactions_group2.csv")
raw.allbehavedata <- `2022_interactions_rawG2`


birdIDs_capture <- read_csv("2022_birdIDs.csv")

birdIDs_capture <- read_csv("2022_birdIDs.csv") 
birdIDs <- birdIDs_capture %>%
  dplyr::select(mark_id22) %>%
  filter(mark_id22!="") # all 20 birds





bird.list <- sort(unique(birdIDs$mark_id22)) # change each time
length(bird.list)
bird.list
length(bird.list)
# list of all possible dyads
dyad.list <- expand.grid(bird.list, bird.list) #head(dyad.list)
names(dyad.list) <- c("actor", "subject")
dyad.list <- subset(dyad.list, actor!=subject)
dyad.list$dyadID <- paste(dyad.list$actor, dyad.list$subject, sep="-")
# list of days with observations
obsday.list <- as.character(unique(raw.allbehavedata$date)) #only days with observations
obsday.list.wday <- as.data.frame(obsday.list)
colnames(obsday.list.wday) <- "date"
obsday.list.wday$nday <- seq(1:length(obsday.list.wday$date))



```


#Data cleaning chunk 2; "other" and "unknown" behaviors
```{r}
behave<-raw.allbehavedata 
unique(behave$behavior)
# other
behave.other<-filter(behave, behavior=="other") %>% dplyr::select(-behavior) %>%
  rename(behavior=other) %>%
  dplyr::select(orderkey, sessionKEY, session_start_timeStamp, date, full_time, time, actor, subject, behavior, everything())
behave.exl.other<-filter(behave, behavior!="other") %>% 
  dplyr::select(-other)
behave.goodother<-bind_rows(behave.exl.other, behave.other)
# unknown
behave.unknown <- filter(behave.goodother, behavior=="unknown") 
behave.unknown$behavior[behave.unknown$behavior=="unknown"] <-"unk"
behave.unknown <- behave.unknown %>%
  unite(behavior, behavior, unknown, sep = "_")
behave$behavior[behave$behavior=="unk agonistic"] <-"unk_agonistic"
behave.exl.unk<-behave.goodother %>% filter(behavior!="unknown") %>%
 dplyr::select(-unknown)
behave.goodunk<-bind_rows(behave.unknown, behave.exl.unk)
behave<-behave.goodunk
head(behave)




```

#Data cleaning chunk 3; prepare cleaned df
```{r}
# keep only observations where the actor is in the list of bird IDs
behave.goodID <- subset(behave, actor %in% bird.list)
# keep only observations where the actor (found above) and the subject are both in the list of bird IDs
behave.goodID <- subset(behave.goodID, subject %in% bird.list)
#finds n behaviors by sessionKEY, date, time, actor, subject, behavior
behave.key <- behave.goodID %>% 
  dplyr::group_by(sessionKEY, date, full_time,actor, subject, behavior) %>% 
  tally() # counts behaviors that were observed within the same minute
#finds max n behaviors per actor by date, time, and behavior type. Return just that summary
behave.maxkey<- behave.key %>% 
  group_by(actor, subject, date, full_time, behavior) %>%
  slice(which.max(n)) %>% # n.aggXaggXkey if summarise, n if tally
  ungroup()
head(behave.maxkey)
#finds n disps per actor by date for summarized/trimmed data
behaveXday <- behave.maxkey %>% 
  group_by(actor, subject, date, full_time, behavior) %>% 
  summarise(n=sum(n))
head(behaveXday)
min(behaveXday$n)





unique(behaveXday$behavior)
# behaviors in long format (1 event at a time)
behaveXday.long <- behaveXday %>%
  uncount(n) %>%
  mutate(n=1)
sum(behaveXday.long$n)
sum(behaveXday$n)
head(behaveXday.long)
## DUPLICATE UNDIRECTED BEHAVIORS
# filter the undirected behaviors 
behaveXday.undirected <- behaveXday.long %>% 
  filter(grepl(pattern="each other",tolower(behavior)))
  
behaveXday.undirected1 <-behaveXday.long %>%
  filter( behavior=="s2s") # spar as well?
behaveXday.undirected <- bind_rows(behaveXday.undirected,behaveXday.undirected1 )
# duplicate undirected dataframe and change subject and actor
behaveXday.undirected.dupl <- behaveXday.undirected %>%
  rename(subject=actor, actor=subject) %>%
  dplyr::select(actor, subject, everything())
# bind both dataframes
behaveXday.directed2022G2.comb <- bind_rows(behaveXday.undirected, behaveXday.undirected.dupl) 
behaveXday.undir2dir <- behaveXday.directed2022G2.comb %>%
  separate( behavior,into = c("behavior", "direction"), sep = "_") %>%
  dplyr::select(-direction)
unique(behaveXday.undir2dir$behavior)
## COMBINE DATAFRAMES
# bind to directed dataframe
behaveXday.directed2022G2 <- behaveXday.long %>% 
  filter(!grepl(pattern="each other",tolower(behavior)) & behavior!="s2s")
unique(behaveXday.directed2022G2$behavior)
behaveXday.directed2022G2 <- bind_rows(behaveXday.directed2022G2, behaveXday.undir2dir)
behaveXday.directed2022G2$behavior[behaveXday.directed2022G2$behavior=="NN"] <- "nn"
behaveXday.directed2022G2$behavior[behaveXday.directed2022G2$behavior=="alloP"] <- "allop"
behaveXday.directed2022G2$behavior[behaveXday.directed2022G2$behavior=="allopreen"] <- "allop"
length(behaveXday.directed2022G2$actor)
unique(behaveXday.directed2022G2$behavior)
12454 + 2587 # 15041
head(behaveXday.directed2022G2)

#Rename cleaned data
'2022_interactions_cleanedg2' <- behaveXday.directed2022G2


```


##Begin non randomized TDR process here
```{r}


#filter out non aggression data
't2022_aggression_onlyG2' <- filter(behaveXday.directed2022G2, behavior %in% c("crowd","displace"))


#subset for time period of interest (Here we are subseting for the first stable period)
t2022_aggression_only_readyG2 <- t2022_aggression_onlyG2[t2022_aggression_onlyG2$date >= "2022-1-26" & t2022_aggression_onlyG2$date <= "2022-1-28	", ]




#sequence for replacing all birdnames with numbers
actornumID <- seq(1:11)
subjectnumID <- seq(1:11)


#Store alphabetcial order of birds in the data set, both for actor and subject. Check to see if both  are identical
actor <- unique(t2022_aggression_only_readyG2$actor)
subject <- unique(t2022_aggression_only_readyG2$subject)
#check length of these to modifyactornumid and subjectnumid
#11
actor
subject
#double check to see whether to use actor or subject bird list
#create vector of the bird ranks that correspond to the alphabetical order of the bird ID list (ex.if  BOB was rank 10 and was the 2nd bird alphabetically,  the 2nd number in the rank vector would be 10
#right now need to manually add in rank but could use bin file to circumvent. Still would #need to know correct bin
#here have to make 2 separate rank lists because birdlists are different
actrank <- c(1,2,6,4,3,8,9,7,10,5)
subrank <- c(2,6,4,3,8,9,11,7,10,5,1)

actor_rank <- actrank
subject_rank <- subrank



#bind ID to coresponding rank for actor
preact <- cbind(actor, actor_rank)


actor_bnumber_bind2 <- cbind(preact, actornumID)

unordered_actor_numbered <- merge(t2022_aggression_only_readyG2, actor_bnumber_bind2)

#bind ID to coresponding rank for subject
presub<- cbind(subject, subject_rank)

subject_bnumber_bind2 <- cbind(presub, subjectnumID)
unordered_both_numbered2 <- merge(unordered_actor_numbered, subject_bnumber_bind2)



#getting everything ordered correctly and formated into a date time column for the first column in the edgelist
unordered_both_numbered2 <- unordered_both_numbered2 %>% dplyr::select(full_time, everything())


both_numbered_sorted2022G2 <- unordered_both_numbered2 %>%
  arrange(unordered_both_numbered2$date, unordered_both_numbered2$full_time)


#ensure that rank is numeric
both_numbered_sorted2022G2$actor_rank <- as.numeric(both_numbered_sorted2022G2$actor_rank)
both_numbered_sorted2022G2$subject_rank <- as.numeric(both_numbered_sorted2022G2$subject_rank)

head(both_numbered_sorted2022G2)



```

```{r}
#start with both_numbered_sorted2022G2

#ensure that ranks are numeric. just double checking
both_numbered_sorted2022G2$actor_rank <- as.numeric(both_numbered_sorted2022G2$actor_rank)
both_numbered_sorted2022G2$subject_rank <- as.numeric(both_numbered_sorted2022G2$subject_rank)

head(both_numbered_sorted2022G2)


#procedure to add obs session

#store the first row as a separate df. It will be binded back on later 
row_1_obs <- both_numbered_sorted2022G2[1,]

#put events side by side. This will allow us to subtract consecutive times from one another to determine whether an event took place on a separate observation session. 
obs_period_pt_1 <- mutate(both_numbered_sorted2022G2, actor_2 = lead(actor),
actor_2_rank = lead(actor_rank), 
subject_2 = lead(subject),                                   
subject_2_rank = lead(subject_rank), 
 full_time_2 = lead(full_time), 
date2 = lead(date))

#add empty columns for observation period and date period
obs_period_pt_1$obs_period <- NA
obs_period_pt_1$date_period <- NA

#create ticker for loop
q <- 1

#loop to calculate observation sessions. If consecutive events were on the same day but there was a long time between events, it is determined that the 2nd event took place in a separate observation session. The ticker goes up, and is reset if events took place on different days.
for (i in 1:nrow(obs_period_pt_1)) {ifelse(obs_period_pt_1$date[i] == obs_period_pt_1$date2[i]
                                            & obs_period_pt_1$full_time_2[i] - obs_period_pt_1$full_time[i] >= 1800, q <- q+1, q <- q)
  ifelse(obs_period_pt_1$date[i] != obs_period_pt_1$date2[i], q <- 1, q <- q)
  obs_period_pt_1$obs_period [i] <- q
  }

#remove original columns and keep mutated columns. These will replace original columns
obs_period_pt_2 <- subset(obs_period_pt_1, select = c(date2,  full_time_2, actor_2, actor_2_rank, subject_2, subject_2_rank, obs_period, date_period  ))

#get rid of the bottom, which will be full of NAs, as the last event in the original data does not have anything that comes after
obs_period_pt_3 <- slice(obs_period_pt_2, 1:(n() - 1))

#rename mutated columns with original names 
setnames(obs_period_pt_3, old = c('date2',  'full_time_2', 'actor_2', 'actor_2_rank', 'subject_2', 'subject_2_rank'), 
         new = c('date',  'full_time', 'actor', 'actor_rank', 'subject', 'subject_rank'))

#add observation period "1" onto first row that we subseted off, as the first event in the data has to take place in obs session 1
row_1_obs$obs_period <- 1 
row_1_obs$date_period <- NA

#ensure that row 1 matches the df
row_1_obs_ready <-  subset(row_1_obs, select = c(date,  full_time, actor, actor_rank, subject, subject_rank, obs_period, date_period  ))

#bind first row and df together
obs_period_pt_4 <- rbind(row_1_obs_ready, obs_period_pt_3)
#add date period 
obs_period_pt_4$date_period <- paste(obs_period_pt_4$date,obs_period_pt_4$obs_period)
head(obs_period_pt_4)
```



#count of rule follows

```{r}



head(obs_period_pt_4)

date_x <- obs_period_pt_4$date
obs <- obs_period_pt_4$date_period
#separate data into a list with each df=a date so we can randomize within days
#sort_by_date <- function(x, i, y) {y <- filter(x, date == i )
#mutate(y, date_counter = i)}


#create empty list to store each bird each day each obs
practdrlist <- list()



dater <- unique(obs)
datex <- c(1: length(unique(obs)))
actorer <- actor
actex <- c(1:length(actor))




#separate data into list of each obs session each day for each bird
for(i in datex) { 
  for (g in actex){
  output <- filter(obs_period_pt_4, obs_period_pt_4$date_period == dater[i] & (subject == actorer[g] | actor == actorer[g]))
   if (nrow(output) < 1) {output [ nrow(output) + 1 , ] <- NA
    } 
  output <- mutate(output, counter = actorer[g])
      practdrlist[[paste0("list", dater[i], actorer[g])]] <- output}}


#arrange df by date and time
practdrlist_ordered2022G2 <- lapply(practdrlist, function(x) arrange(x, date, full_time))

```

```{r}

#modified each data frame to put consecutive events side by side

testall <- lapply(practdrlist_ordered2022G2, function(x) mutate(x, actor_2 = lead(actor), subject_2 = lead(subject), full_time_2 = lead(full_time), date2 = lead(date))) 

head(testall[[1]])




```


```{r}
#successfully picked out retaliation rule while keeping all dataframes in a list 
#loop to set conditionals to pick out retaliation

#counter corresponds with which birds dataframe I am looking at and is used to control for false positives 
#for example, if retaliation is detected for a bird whos specific dataframe I am not looking at , this may be a false positive, as that birds interactions are not all listed in the dataframe of another bird. In other words, the bird may have done something else to another bird that is not listed, as it would be only listed in that specific birds dataframe

dateact1 <-  c(1:length(testall))



for(i in dateact1) {
  testall[[i]] <- mutate(testall[[i]], 
                         initiated = ifelse(subject == counter, "yes","no"), 
                         rule_followed = ifelse(actor == subject_2 
                                                & subject == actor_2 
                                                & full_time_2 - full_time <= 336 
                                                & full_time_2 - full_time > 0
                                                & date2 == date
                                                & subject == counter
                                                & actor_2 == counter,
                                                "yes","no"))
} 



head(testall[[3]])





```

```{r}


#combine dataframes into one huge dataframe
testhuge <- bind_rows(testall, .id = "column_label")

#sort by time and date
testhugesorted <- testhuge %>%
  arrange(testhuge$date, testhuge$full_time)


#Remove duplicate events, events that have been represented twice, and events that could not confidently be counted as the start of retaliation
testhugesorted_no_dupr <- subset(testhugesorted, initiated != "no") 

#subset for desired columns
retaliation_no_dupr2022G2 <- subset(testhugesorted_no_dupr, select = c(date, full_time, actor, subject, 
                                                               counter, actor_2, subject_2, full_time_2, date2, 
                                                               initiated, rule_followed))

head(retaliation_no_dupr2022G2)

#determine how many times rule was followed
retal_real2022G2 <- length(which(retaliation_no_dupr2022G2$rule_followed == "yes"))

retal_real.frame2022G2 <- data.frame(retal_real2022G2)


retal_real.frame2022G2

#create df of only rule follows
retal_doner_all_yes <-filter(retaliation_no_dupr2022G2, rule_followed == "yes")


```
#individ rule follows
```{r}
#test for individual use
unique(retal_doner_all_yes$actor_2)
length(unique(retal_doner_all_yes$actor_2)
)

summary.retal.individ_2022G2 <- retal_doner_all_yes %>% group_by(actor_2) %>%
  dplyr::summarize (
    count =n())

summary.retal.individ_2022G2



#Calculate Richness score for rule following
#compare to raw dataset to see if any birds didnt use rule at all
unique(t2022_aggression_onlyG2$actor)
unique(t2022_aggression_onlyG2$subject)


retal_nofollow <- setdiff(unique(t2022_aggression_onlyG2$actor), unique(retal_doner_all_yes$actor_2)
 )

#DO FIRST BEFORE ADDING ZEROS AND DONT DO AGAIN WITHOUT RUNNING ABOVE CODE
retal_richness <- length(summary.retal.individ_2022G2$actor_2)/length((unique(t2022_aggression_onlyG2$actor)
))


#add in 0s for individuals who did not follow rule for plotting purposes
retal_zeros <- rep(c(0),times=c(length(retal_nofollow)))


retal_nofollow_zeros<- data.frame(retal_nofollow,retal_zeros) 

colnames(retal_nofollow_zeros) <- c("actor_2","count")

summary.retal.individ_2022G2 <- rbind(summary.retal.individ_2022G2, retal_nofollow_zeros)




# Plot
individ_retal_plot_2022G2 <- ggplot(summary.retal.individ_2022G2, aes(x = actor_2, y = count )) + 
  geom_bar(stat = "identity", width = 0.6) + # Consistent bar width
scale_y_continuous( breaks = seq(0, 60, 2)) + 
  theme_minimal()  +
  theme(
    axis.text.x = element_text(angle = 90, vjust=0.5),
    axis.title.x = element_text( face = "bold",  margin = margin(t = 15)),  # X-axis title
    axis.title.y = element_text( face = "bold",  margin = margin(r = 15)),
    ) +
  labs(
    x = "Parakeet ID",  # Add your custom x-axis title here
    y = "Count of rule follows"   # Add your custom y-axis title here
  )




individ_retal_plot_2022G2

#Calculate eveness metric
retal_for_even <- subset(summary.retal.individ_2022G2, select = c(count))

final_retal_for_even <- as.data.frame(t(retal_for_even))

retal_even_value <-calcDiv(final_retal_for_even, type = "PielouEven", q = 1) 

retal_even_value

```


#Calculate rule speed
```{r}
#######################################################################################################
#test for length of retals


#follows similar procedure as calculating the count of rule follows, with some differences in the rule detection loop and the structure

#put df side by side
testall_rule_time <- lapply(practdrlist_ordered2022G2, function(x) mutate(x, actor_2 = lead(actor), subject_2 = lead(subject), full_time_2 = lead(full_time), date2 = lead(date)))


#test for length of retal in seconds
for(i in dateact1) {
  testall_rule_time[[i]] <- mutate(testall_rule_time[[i]], 
                         initiated = ifelse(subject == counter, "yes","no"), 
                         rule_followed = ifelse(actor == subject_2 
                                                & subject == actor_2 
                                                & date2 == date
                                                & subject == counter
                                                & actor_2 == counter
                                                & full_time_2 - full_time > 0,
                                                "yes","no"),
                         time_to_retal = full_time_2 - full_time)
} 



#bind list of dfs into one df
testhuge_rule_time <- bind_rows(testall_rule_time, .id = "column_label")

#sort by time and date
testhugesorted_rule_time <- testhuge_rule_time %>%
  arrange(testhuge_rule_time$date, testhuge_rule_time$full_time)



#remove any duplicate or double counted events 
testhugesorted_no_dupr_rule_time <- subset(testhugesorted_rule_time, initiated != "no") 

#subset for columns of interest
retaliation_no_dupr_rule_time <- subset(testhugesorted_no_dupr_rule_time, select = c(date, full_time, actor, subject,  
                                                               counter, actor_2, subject_2, full_time_2, date2, 
                                                               initiated, rule_followed, time_to_retal, date_period))

#get df where rule was followed
retal_length <- subset(retaliation_no_dupr_rule_time, rule_followed != "no")

#subset for columns of interest
retal_length_ready2022G2 <- subset( retal_length, select = c(actor, subject, actor_2, subject_2, time_to_retal,date_period))
head(retal_length_ready2022G2)

#summarize the speed of rule follows. Here we are checking whether the speed of the rule in question tends to be clustered
summary.retal2022G2 <- retal_length_ready2022G2 %>% group_by(time_to_retal) %>%
  summarize (
    count =n())


summary.retal2022G2

#quick glimpses of the distribution of rule speeds
ggplot(retal_length_ready2022G2, aes(x=time_to_retal)) + 
  geom_histogram(aes(y=..density..),      
                 binwidth= 50,
                 colour="black", fill="white") + 
  geom_density()





ggplot(retal_length_ready2022G2, aes(x=time_to_retal)) + 
  geom_histogram(aes(y=..density..),      
                 binwidth=10,
                 colour="black", fill="white") + 
  geom_density() +   scale_x_continuous(name = "length in s of retal events", limits = c(0,3000)) +
  ggtitle("2022 Group 2")


retal_length_ready2022G2

```



##Randomization/permutation process starts here

```{r}

#start with "both_numbered_sorted" as my dataset


head(both_numbered_sorted2022G2)


#procedure to randomize within obs sesh
#store first  row
row_1_obs <- both_numbered_sorted2022G2[1,]


#put events side by side. This will allow us to subtract consecutive times from one another to determine whether an event took place on a separate observation session. 
obs_period_pt_1 <- mutate(both_numbered_sorted2022G2, actor_2 = lead(actor),
actor_2_rank = lead(actor_rank), 
subject_2 = lead(subject),                                   
subject_2_rank = lead(subject_rank), 
 full_time_2 = lead(full_time), 
date2 = lead(date))



#add empty columns for observation period and date period
obs_period_pt_1$obs_period <- NA
obs_period_pt_1$date_period <- NA

#create ticker for loop
q <- 1

#loop to calculate observation sessions. If consecutive events were on the same day but there was a long time between events, it is determined that the 2nd event took place in a separate observation session. The ticker goes up, and is reset if events took place on different days.
for (i in 1:nrow(obs_period_pt_1)) {ifelse(obs_period_pt_1$date[i] == obs_period_pt_1$date2[i]
                                            & obs_period_pt_1$full_time_2[i] - obs_period_pt_1$full_time[i] >= 1800, q <- q+1, q <- q)
  ifelse(obs_period_pt_1$date[i] != obs_period_pt_1$date2[i], q <- 1, q <- q)
  obs_period_pt_1$obs_period [i] <- q
  }

#remove original columns and keep mutated columns. These will replace original columns
obs_period_pt_2 <- subset(obs_period_pt_1, select = c(date2,  full_time_2, actor_2, actor_2_rank, subject_2, subject_2_rank, obs_period, date_period  ))

#get rid of the bottom, which will be full of NAs, as the last event in the original data does not have anything that comes after
obs_period_pt_3 <- slice(obs_period_pt_2, 1:(n() - 1))

#rename mutated columns with original names 
setnames(obs_period_pt_3, old = c('date2',  'full_time_2', 'actor_2', 'actor_2_rank', 'subject_2', 'subject_2_rank'), 
         new = c('date',  'full_time', 'actor', 'actor_rank', 'subject', 'subject_rank'))

#add observation period "1" onto first row that we subseted off, as the first event in the data has to take place in obs session 1
row_1_obs$obs_period <- 1 
row_1_obs$date_period <- NA

#ensure that row 1 matches the df
row_1_obs_ready <-  subset(row_1_obs, select = c(date,  full_time, actor, actor_rank, subject, subject_rank, obs_period, date_period  ))

#bind first row and df together
obs_period_pt_4 <- rbind(row_1_obs_ready, obs_period_pt_3)
#add date period
obs_period_pt_4$date_period <- paste(obs_period_pt_4$date,obs_period_pt_4$obs_period)





obs <- obs_period_pt_4$date_period
#separate data into a list with each df=a date period so we can randomize within days and obs periods


datelist <- list()
dater <- unique(obs)
datex <- c(1: length(unique(obs)))
#boop <- filter(both_numbered_sorted, both_numbered_sorted$date == datex [2])

#loop to create a separate dataframe for of each obs session each day 
#Each dataframe is stored within a list to make the dataframes easy to work with
#We wish to conserve our permutation randomization within days and, more specifically, within observation sessions
for(i in datex) { 
  output <- filter(obs_period_pt_4, obs_period_pt_4$date_period == dater[i] )
   if (nrow(output) < 1) {output [ nrow(output) + 1 , ] <- NA
    } 
      datelist[[paste0("list", dater[i])]] <- output}



#run ids should be 1 through however many times you want to run through the permutation
runIDs <- seq(1,1000)

#create an empty masterframe to be filled with each run of the permutation
masterframe_retaliation.df2022G2 <- data.frame(runIDs = character(),
                             actor = character(),
                             subject = character(),
                             date = character(),
                             full_time = integer(),
                             counter = character(),
                             actor_2 = character(),
                             subject_2 = character(),
                             full_time_2 = integer(),
                             date2 = character(),
                             initiated = character(),
                             rule_followed = character(),
                             stringsAsFactors=FALSE)


nruns <- 1000
#progress bar
pb = txtProgressBar(min=0, max = nruns, style = 3)
#forloop starts here'

#set seed
set.seed(201)
#seed for unrestricted = 99
#seed for 8 sec = 177
#seed for 85= 633
#seed for 336 = 201
for (r in 1:length(runIDs)) { #r = 1 is a test you can uncomment to see if it works before #running it 1000 times
#r = 1
  run <- r
  setTxtProgressBar(pb, r) #update progress bar
  loop.run <- paste("run", run) 
  loop.run
  #for example, if r = 1, looprun will say run 1 which will allow you to keep each run's #data straight
  
    
#loop.seed <- set.seed[r] didnt work so ignore. not needed

  
  #renamed data
  loop.datalist <- datelist
  head(loop.datalist[[3]])
  xorder <- c()
  listlength <- as.numeric(length(loop.datalist))
datex2 <- 1:listlength
  full_time_list <-c()
  loop.data.randomized.time.added <- c()
  #get rid of anything thats not actor and receiver (we will bind back on the date and time #later anyways to preserve
  #their order)
  
   for(i in datex2) {
     #store time
     full_time_list[[i]] <- subset(loop.datalist[[i]], select = c(full_time))
          #remove time from each df in the list. randomizing the order of time wouldnt make sense
         loop.datalist[[i]] <- subset(loop.datalist[[i]], select = -c(full_time))
#create a randomized sequence of numbers to bind to the subset data (ex. 2,6,1,3,5,4)
      #sort the data frame to put the randomized numbers in order from 1 to whatever and voila, the order of events has been randomized (ex.  from above 1,2,3,4,5,6)
    xorder[[i]] <- data.frame(xorder = sample(1:length(loop.datalist[[i]]$actor),
                                              length(loop.datalist[[i]]$actor)))
        #bind random order to df
    loop.datalist[[i]] <- mutate(loop.datalist[[i]], 
                                 xorderx = xorder[[i]]$xorder)
        #put randomized order of numbers in order to randomize rows in the dataset
    loop.datalist[[i]] <-
      loop.datalist[[i]][order(loop.datalist[[i]]$xorderx),]
    #bind time back on
    loop.data.randomized.time.added[[i]] <- bind_cols(loop.datalist[[i]], full_time_list[[i]])
    loop.data.randomized.time.added[[i]] <- subset(loop.data.randomized.time.added[[i]], select = -c(xorderx))

   }

  #rename df
 practdrlist <- loop.data.randomized.time.added


#separate data into list of each obs session each day for each bird
actorer <- actor
actex <- c(1:length(actor))
dater <- unique(obs)
practdrlist_split_by_bird <- c()

for(i in datex2) {
for (g in actex) {output <- subset(practdrlist[[i]], actor == actorer[g] |  subject == actorer[g])
   if (nrow(output) < 1) {output [ nrow(output) + 1 , ] <- NA
    } 
  output <- mutate(output, counter = actorer[g])
  practdrlist_split_by_bird[[paste0("list", dater[i], actorer[g])]] <- output
}}


#sort by date and time
practdrlist_ordered <- lapply(practdrlist_split_by_bird, function(x) arrange(x, date, full_time))





#modified each data frame to put consecutive events side by side

testall <- lapply(practdrlist_ordered, function(x) mutate(x, actor_2 = lead(actor), subject_2 = lead(subject), full_time_2 = lead(full_time), date2 = lead(date))) 

head(testall[[1]])



#loop to set conditionals to pick out retaliation

#counter corresponds with which birds dataframe I am looking at and is used to control for false positives 
#for example, if retaliation is detected for a bird whos specific dataframe I am not looking #at , this may be a false positive, as that birds interactions are not all listed in the #dataframe of another bird. In other words, the bird may have done something else to another #bird that is not listed, as it would be only listed in that specific birds dataframe

for(i in dateact1) {
  testall[[i]] <- mutate(testall[[i]], 
                         initiated = ifelse(subject == counter, "yes","no"), 
                         rule_followed = ifelse(actor == subject_2 
                                                & subject == actor_2 
                                                & full_time_2 - full_time <= 336 
                                                & full_time_2 - full_time > 0
                                                & date2 == date
                                                & subject == counter
                                                & actor_2 == counter,
                                                "yes","no"))
} 


head(testall[[1]])







#combine dataframes into one huge dataframe
testhuge <- bind_rows(testall, .id = "column_label")

#sort by time and date
testhugesorted <- testhuge %>%
  arrange(testhuge$date, testhuge$full_time)


#Remove duplicate events, events that have been represented twice, and events that could not confidently be counted as the start of retaliation
testhugesorted_no_dup <- subset(testhugesorted, initiated != "no") 


#subset for columns of interest
retaliation_no_dup <- subset(testhugesorted_no_dup, select = c(date, full_time, actor, subject, 
                                                               counter, actor_2, subject_2, full_time_2, date2, 
                                                               initiated, rule_followed))

head(retaliation_no_dup)




  
  #end of retaliation process
  #end of rule code
  
  
  
  #bind vector of run IDs for each run to the dataframe so that you can have a numeric run #id next to each data point
  #that coresponds with that run which will allow you to sort/put them in ascending order later
 runIDs <- rep(loop.run, length(retaliation_no_dup$actor))
 
  retaliation_complete <- cbind(runIDs, retaliation_no_dup)
  
  
#put each runs data into teh masterframe
  masterframe_retaliation.df2022G2 <- rbind(masterframe_retaliation.df2022G2, retaliation_complete)
  
}


#write.csv(masterframe_retaliation.df2022G2, "C:/Users/Xmanf/Desktop/Ch1 TDR files/retal2022G2countmaster_336sec.csv")

```

```{r}

#masterframe_retaliation.df2022G2 <- read.csv("C:/Users/Xmanf/Desktop/Ch1 TDR files/retal2022G2countmaster_336sec.csv", header=TRUE, stringsAsFactors=FALSE)

#put run #s in an ascending vector
cum_run_IDS <- unique(masterframe_retaliation.df2022G2$runIDs)

#create empty vector for number of time the rules were followed to be stored
random_times_retaliation_followed <- c()



#put the number of times the rule was followed into the vector for analysis 
for (j in cum_run_IDS) {
  len_of_retaliations <- length(which(masterframe_retaliation.df2022G2$rule_followed == "yes" & 
                                        masterframe_retaliation.df2022G2$runIDs == j))

random_times_retaliation_followed <- c(random_times_retaliation_followed, len_of_retaliations)
}

#turn vector into a dataframe for analysis
rand_retal_.frame2022G2 <- data.frame(random_times_retaliation_followed)

#plot time (the x intercept is the # of time a rule was used in the real data, found with 
#"retal_real <- length(which(retaliation_no_dupr$rule_followed == "yes"))
#retal_real.frame <- data.frame(retal_real))"

#visualize observed rule follow vs reference distribution
retal_2022G2_count_plot <- ggplot(rand_retal_.frame2022G2, aes(x=random_times_retaliation_followed)) + 
  geom_histogram(aes(y=..density..),      
                 binwidth = .9,
                 colour="black", fill="grey") +
  geom_density(lwd = 1, linetype = 1) + theme_minimal() +
  geom_vline(xintercept = retal_real2022G2, colour = "red", size = 2)  + theme(axis.text = element_text(size=25), axis.title= element_blank()) +
  scale_x_continuous(name = "Count of Retaliation events", breaks=seq(0, 20, 5)) +  
     coord_cartesian(xlim = c(0, 20), ylim = c(0,.4)) +
scale_y_continuous(breaks = seq(0, .4, .1)) 

retal_2022G2_count_plot


#calculate p value (proportion of randomized reference values that are more "extreme" than the observed count of rule follows)
retal_tally2022G2 <-length(which(rand_retal_.frame2022G2$random_times_retaliation_followed < retal_real2022G2))

pretal_tally2022G2 <- 1-  retal_tally2022G2/length(rand_retal_.frame2022G2$random_times_retaliation_followed)

#check others
#p = 0 for unrestricted
#p = 0 for 8 sec
#p = 0 for 85 sec
#p = .036 for 336
```






#randomize rule speed
```{r}

#randomize time between initiation and response between events
#ALWAYS RUN OBSERVED TIME CODE FIRST

testall_rule_time_ready_for_rand <- lapply(practdrlist_ordered2022G2, function(x) mutate(x, actor_2 = lead(actor), subject_2 = lead(subject), full_time_2 = lead(full_time), date2 = lead(date)))

#Loop to detect instances and speed of rule use for the rule in question 
for(i in dateact1) {
  testall_rule_time_ready_for_rand[[i]] <- mutate(testall_rule_time_ready_for_rand[[i]], 
                         initiated = ifelse(subject == counter, "yes","no"), 
                         rule_followed = ifelse(actor == subject_2 
                                                & subject == actor_2 
                                                & date2 == date
                                                & subject == counter
                                                & actor_2 == counter
                                                & full_time_2 - full_time > 0,
                                                "yes","no"),
                         time_to_retal = full_time_2 - full_time)
} 



testall_rule_time_ready_for_rand_binded <- bind_rows(testall_rule_time_ready_for_rand)

#mark df with priority of which to favor when getting rid of. Unlike in the procedure for rule detection and event order permutations, here we only want to get rid of duplicate/double counted event sequences, not events that may not initiate retaliation. Our subsequent permutations involve shuffling the time between events, regardless of if the sequences of events represent a rule follow or not, and so preserving the data detailing the time between non retaliation events is essential.
testall_rule_time_ready_for_rand_binded_marked <- mutate(testall_rule_time_ready_for_rand_binded, priority = ifelse(rule_followed == "yes", 1, 2))
#sort by priority
testall_rule_time_ready_for_rand_binded_marked <- arrange(testall_rule_time_ready_for_rand_binded_marked, priority)

#Remove duplicate and double counted sequences
testall_rule_time_ready_for_rand_binded_marked <- distinct(testall_rule_time_ready_for_rand_binded_marked, date, full_time, actor, actor_rank, subject, subject_rank, obs_period, date_period, actor_2, subject_2, full_time_2, date2, time_to_retal, .keep_all= TRUE) 



#remove instances of rule use whos speed were calculated to be 0. In this case we cant be certain of which event actually came first
testall_rule_time_ready_for_rand_binded_marked <- filter(testall_rule_time_ready_for_rand_binded_marked, time_to_retal != 0)


date_x <- testall_rule_time_ready_for_rand_binded_marked$date
obs <- testall_rule_time_ready_for_rand_binded_marked$date_period
#separate data into a list with each df=a date so we can randomize within days
#sort_by_date <- function(x, i, y) {y <- filter(x, date == i )
#mutate(y, date_counter = i)}

testall_rule_time_ready_for_rand_list <- list()
dater <- unique(obs)
datex <- c(1: length(unique(obs)))
#boop <- filter(both_numbered_sorted, both_numbered_sorted$date == datex [2])

#loop to create a separate dataframe for each bird that only contains interactions #pertaining to that bird.
#Each dataframe is stored within a list to make the dataframes easy to work with
#separate data into list of each obs session each day 
for(i in datex) { 
  output <- filter(testall_rule_time_ready_for_rand_binded_marked, testall_rule_time_ready_for_rand_binded_marked$date_period == dater[i] )
   if (nrow(output) < 1) {output [ nrow(output) + 1 , ] <- NA
    } 
      testall_rule_time_ready_for_rand_list[[paste0("list", dater[i])]] <- output}







nruns <- 1000

pb = txtProgressBar(min=0, max = nruns, style = 3)

#run ids should be 1 through however many times you want to run through the permutation
runIDs <- seq(1,1000)

#create an empty masterframe to be filled with each run of the permutation
masterframe_retaliation.df_time_2022G2 <- data.frame(runIDs = character(),
                             actor = character(),
                             subject = character(),
                             date = character(),
                             full_time = integer(),
                             counter = character(),
                             actor_2 = character(),
                             subject_2 = character(),
                             full_time_2 = integer(),
                             date2 = character(),
                             initiated = character(),
                             rule_followed = character(),
                             time_to_retal = integer(),
                            date_period = character(),
                             stringsAsFactors=FALSE)


set.seed(307)
#forloop starts here'
for (r in 1:length(runIDs)) { #r = 1 is a test you can uncomment to see if it works before #running it 100 times
#r = 1
  run <- r
      setTxtProgressBar(pb, r) #update progress bar
  loop.run <- paste("run", run) 
  loop.run
  #for example, if r = 1, looprun will say run 1 which will allow you to keep each run's #data straight
  
    

  
  #renamed data
  loop.datalist <- testall_rule_time_ready_for_rand_list
    head(loop.datalist[[3]])
    xorder <- c()
  listlength <- as.numeric(length(loop.datalist))
datex2 <- 1:listlength
  full_time_to_rule <-c()
  loop.data.randomized.time_to_rule.added <- c()
    
    

  for(i in datex2) {
         #store time
     full_time_to_rule[[i]] <- subset(loop.datalist[[i]], select = c(time_to_retal))     
     #remove time from each df in the list. randomizing the order of time wouldnt make sense
     loop.datalist[[i]] <- subset(loop.datalist[[i]], select = -c(time_to_retal))
      #create a randomized sequence of numbers to bind to the subset data (ex. 2,6,1,3,5,4)
      #sort the data frame to put the randomized numbers in order from 1 to whatever and voila, the time between events (speed) has been  randomized (ex. from above 1,2,3,4,5,6)
    xorder[[i]] <- data.frame(xorder = sample(1:length(full_time_to_rule[[i]]$time_to_retal),
                                              length(full_time_to_rule[[i]]$time_to_retal)))
    #bind random order to df
    full_time_to_rule[[i]] <- mutate(full_time_to_rule[[i]], 
                                 xorderx = xorder[[i]]$xorder)
    #put randomized order of numbers in order to randomize speed in the dataset
    full_time_to_rule[[i]] <-
      full_time_to_rule[[i]][order(full_time_to_rule[[i]]$xorderx),]
    #bind time back on
    loop.data.randomized.time_to_rule.added[[i]] <- bind_cols(loop.datalist[[i]], full_time_to_rule[[i]])
    loop.data.randomized.time_to_rule.added[[i]] <- subset(loop.data.randomized.time_to_rule.added[[i]], select = -c(xorderx))

   }
  

  
  
  
  
  
  
  

#combine dataframes into one huge dataframe
loop.datalist_time_randomized_binded_tested_retal_2022G2 <- bind_rows(loop.data.randomized.time_to_rule.added, .id = "column_label")


 

#sort by time and date
loop.datalist_time_randomized_binded_tested_retal_2022G2 <- loop.datalist_time_randomized_binded_tested_retal_2022G2 %>%
  arrange(loop.datalist_time_randomized_binded_tested_retal_2022G2$date, loop.datalist_time_randomized_binded_tested_retal_2022G2$full_time)






#Remove duplicate events, events that have been represented twice, and events that could not confidently be counted as the start of retaliation
testhugesorted_no_dup_rand_time <- subset(loop.datalist_time_randomized_binded_tested_retal_2022G2, initiated != "no") 

retaliation_no_dup_rand_time <- subset(testhugesorted_no_dup_rand_time, select = c(date, full_time, actor, subject, 
                                                               counter, actor_2, subject_2, full_time_2, date2, 
                                                               initiated,  rule_followed,time_to_retal, date_period))





  
  #end of retaliation process
  #end of rule code
  
  
  
  #bind vector of run IDs for each run to the dataframe so that you can have a numeric run #id next to each data point
  #that coresponds with that run which will allow you to sort/put them in ascending order later
 runIDs <- rep(loop.run, length(retaliation_no_dup_rand_time$actor))
 
  retaliation_complete_rand_time_2022G2 <- cbind(runIDs, retaliation_no_dup_rand_time)
  
  
#put each runs data into teh masterframe
  masterframe_retaliation.df_time_2022G2 <- rbind(masterframe_retaliation.df_time_2022G2, retaliation_complete_rand_time_2022G2)
  
}





#write.csv(masterframe_retaliation.df_time_2022G2, "C:/Users/Xmanf/Desktop/Ch1 TDR files/retal2022G2timemaster.csv")
```



#rule speed vs random
```{r}

#masterframe_retaliation.df_time_2022G2 <- read.csv("C:/Users/Xmanf/Desktop/Ch1 TDR files/retal2022G2timemaster.csv")
head(masterframe_retaliation.df_time_2022G2)

#subset masterframe so that only rule follows are included
masterframe_retaliation.df_time_2022G2_only_follows <- subset(masterframe_retaliation.df_time_2022G2, rule_followed == "yes" )

#isolate time it takes to carry out rule...
masterframe_retaliation_time_sub.df <- subset( masterframe_retaliation.df_time_2022G2_only_follows, select = c(actor, subject, actor_2,subject_2, time_to_retal,date_period))
head(masterframe_retaliation_time_sub.df)



#add data label for the randomized rule speed
masterframe_retaliation_time_ready.df <- mutate(masterframe_retaliation_time_sub.df, data_type = "randomized")

#ensure that time is numeric
masterframe_retaliation_time_ready.df$time_to_retal <- as.numeric(masterframe_retaliation_time_ready.df$time_to_retal)


head(retal_length_ready2022G2)

#add data label for the observed rule speed
retal_length_ready_2022G2_label <- mutate(retal_length_ready2022G2, data_type = "observed")


#combine df for observed rule speed and randomized rule speed into one df
retal_length_ready_2022G2_comb <- rbind(masterframe_retaliation_time_ready.df, retal_length_ready_2022G2_label )
unique(retal_length_ready_2022G2_comb$data_type)




#provide label for rule in question
retal_length_ready_2022G2_comb <- mutate(retal_length_ready_2022G2_comb, rule = "Retaliation")


#make sure that rule speed is numeric
retal_length_ready_2022G2_comb$time_to_retal <- as.numeric(retal_length_ready_2022G2_comb$time_to_retal)


#observed vs randomized raw plot. quick look at how the distriubtuions compare
ggplot(retal_length_ready_2022G2_comb, aes(x=time_to_retal, fill = data_type)) + 
  geom_histogram(aes(y=..density..),      
                 binwidth=1) +#,
                 #colour="black", fill="white") + 
  geom_density() +   scale_x_continuous(name = "length in s of retal events random vs observed", limits = c(0,300)) 


#obtain mode of observed and randomized rule speed for plotting purposes
#getmode <- function(v) {
   #uniqv <- unique(v)
   #uniqv[which.max(tabulate(match(v, uniqv)))]
#}

#retal_2022G2_mode_obs <- getmode(retal_length_ready_2022G2_label$time_to_retal)

#retal_2022G2_mode_rand <-getmode(masterframe_retaliation_time_ready.df$time_to_retal)

#bind mode to dfs
#retal_2022G2_mode <-  rbind(retal_2022G2_mode_obs,retal_2022G2_mode_rand)

#test for homogeneity of variance
leveneTest(time_to_retal ~ data_type, data = retal_length_ready_2022G2_comb)


#split violin plot of observed vs randomized rule speed
retal_violin_plot <- ggplot(retal_length_ready_2022G2_comb, aes(rule, time_to_retal, fill = data_type))  +
  introdataviz::geom_split_violin(alpha= .9, trim = TRUE, show.legend = FALSE) +
  geom_boxplot(width = .2, alpha = .2, fatten = 2, show.legend = FALSE, outlier.shape = NA) +
  #stat_summary(fun = "mean", geom = "point",  colour = "darkblue", show.legend = F, 
               #position = position_dodge(.200))  +
  scale_x_discrete(name = "Time Dependent Rule") +  
     coord_cartesian(ylim = c(0, 1000)) +
  scale_y_continuous(name = "Speed of Retaliation events (s)",
                     breaks = seq(0, 1000, 200) 
                     ) + scale_fill_manual(values=c("red","gray")) +
  theme_minimal(base_size = 20)  + theme(axis.text.y = element_text(size=25), axis.title= element_blank(), axis.text.x = element_blank())


retal_2022G2_time_plot <- retal_violin_plot

retal_2022G2_time_plot

#calculate the means for observed and randomized rule speed
mean_obs_rand_retaliation_2022G2 <- retal_length_ready_2022G2_comb %>% group_by(data_type) %>%
  dplyr::summarize (mean(time_to_retal))

mean_obs_rand_retaliation_2022G2
#obs 373.800
#rand 307.1212


#linear mixed model to compare means of observed vs randomized rule speed
m1retal <- glmer(time_to_retal ~ data_type + (1 | actor_2) + (1 | date_period), data = retal_length_ready_2022G2_comb ,   control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun=2e5)), family = Gamma(link = "log"))
summary(m1retal)
#something like 0.813    





 #calculate confidence intervals  

 confint_retal_2022G2 <- round(confint(m1retal, method = "Wald", level = 0.95), 3)
confint_retal_2022G2
#tukey
summary(glht(m1retal, linfct = mcp(data_type="Tukey")), test = adjusted("none"))
#find R2 values
tab_model(m1retal)
```




```{r}
#ensure that observed rule speed is numeric
retal_length_ready2022G2$time_to_retal <- as.numeric(retal_length_ready2022G2$time_to_retal)


head(retal_length_ready2022G2)

#convert to a density matrix
#summarize the count of various rule speeds
summary.retal_length_ready2022G2 <- retal_length_ready2022G2 %>% group_by(time_to_retal) %>%
  dplyr::summarize (
    count =n())

summary.retal_length_ready2022G2

#Add density column
summary.retal_length_ready2022G2_density <- mutate(summary.retal_length_ready2022G2, density = count/sum(count))
#remove count column
summary.retal_length_ready2022G2_density_no_count <- subset(summary.retal_length_ready2022G2_density, select = -c(count))
#reorder the columns
summary.retal_length_ready2022G2_density_no_count_reordered <- summary.retal_length_ready2022G2_density_no_count[, c(2, 1)]
head(summary.retal_length_ready2022G2_density_no_count_reordered)
#convert to matrix
summary.retal_length_ready2022G2_density_no_count_reordered_mat <- as.matrix(summary.retal_length_ready2022G2_density_no_count_reordered)



masterframe_length_ready <- subset(masterframe_retaliation_time_sub.df, select = c(time_to_retal))
head(masterframe_length_ready)
#ensure that randomized rule follows are numeric
masterframe_length_ready$time_to_retal <- as.numeric(masterframe_length_ready$time_to_retal)




#convert to a density matrix
#summarize the count of avrious rule speeds
summary.masterframe_length_ready <- masterframe_length_ready %>% group_by(time_to_retal) %>%
  dplyr::summarize (
    count =n())

summary.masterframe_length_ready

#Adddensity column
summary.masterframe_length_ready_density <- mutate(summary.masterframe_length_ready, density = count/sum(count))
#remove count column
summary.masterframe_length_ready_density_no_count <- subset(summary.masterframe_length_ready_density, select = -c(count))
#reorder the columns
summary.masterframe_length_ready_density_no_count_reordered <- summary.masterframe_length_ready_density_no_count[, c(2, 1)]
head(summary.masterframe_length_ready_density_no_count_reordered)
#convert to matrix
summary.masterframe_length_ready_density_no_count_reordered_mat <- as.matrix(summary.masterframe_length_ready_density_no_count_reordered)


#Calculate EMD between observed and randomized rule speed
retal_obs_vs_rand_emd <- emdist::emd(summary.retal_length_ready2022G2_density_no_count_reordered_mat, summary.masterframe_length_ready_density_no_count_reordered_mat)
retal_obs_vs_rand_emd
# 168.3836






```




































```{r}
head(masterframe_retaliation.df2022G2)

masterframe_retaliation_time_nc.df <- subset(masterframe_retaliation.df2022G2, select = -c(rule_followed))

masterframe_retaliation_time.df <- mutate(masterframe_retaliation_time_nc.df, 
                                          rule_followed = ifelse(actor == subject_2 
                                                & subject == actor_2 
                                                & date2 == date,
                                                "yes","no"),
                         time_to_retal = full_time_2 - full_time)  

masterframe_retaliation_time_sub_full.df <- subset(masterframe_retaliation_time.df, rule_followed != "no") 




masterframe_retaliation_time_sub.df <- subset( masterframe_retaliation_time_sub_full.df, select = c(time_to_retal))
head(masterframe_retaliation_time_sub.df)

masterframe_retaliation_time_ready.df <- mutate(masterframe_retaliation_time_sub.df, data_type = "randomized")


head(retal_length_ready2022G2)

retal_length_ready_label <- mutate(retal_length_ready2022G2, data_type = "observed")


retal_length_ready_comb2022G2 <- rbind(masterframe_retaliation_time_ready.df, retal_length_ready_label )


#observed vs randomized raw
ggplot(retal_length_ready_comb2022G2, aes(x=time_to_retal, fill = data_type)) + 
  geom_histogram(aes(y=..density..),      
                 binwidth=1) +#,
                 #colour="black", fill="white") + 
  geom_density() +   scale_x_continuous(name = "length in s of retal events random vs observed", limits = c(0,300)) 





```


```{r}
masterframe_retaliation_time_run.df <- subset( masterframe_retaliation_time_sub_full.df, select = c(time_to_retal, runIDs ))

colnames(masterframe_retaliation_time_run.df) <- c('time_to_retal','data_type') 
head(masterframe_retaliation_time_run.df)


xrandnum_retal <- paste("run",sample(1:1000, 5))
xrandnum_retal

masterframe_retaliation_time_run_sub.df <- subset(masterframe_retaliation_time_run.df, data_type == xrandnum_retal)


retal_length_ready_comb_five2022G2 <- rbind(masterframe_retaliation_time_run_sub.df, retal_length_ready_label )


#observed vs randomized raw
ggplot(retal_length_ready_comb_five2022G2, aes(x=time_to_retal, fill = data_type)) + 
  geom_histogram(aes(y=..density..),      
                 binwidth=1) +#,
                 #colour="black", fill="white") + 
  geom_density() +   scale_x_continuous(name = "length in s of five retal events random vs observed", limits = c(0,100)) 


```


```{r}
head(retal_length_ready_label)

retal_length_ready_label$time_to_retal <- as.numeric(retal_length_ready_label$time_to_retal)

retal_length_ready_avg2022G2 <- mean(retal_length_ready_label$time_to_retal)

masterframe_retaliation_time_run.df$time_to_retal <- as.numeric(masterframe_retaliation_time_run.df$time_to_retal)


retal_rand_avgs2022G2 <- masterframe_retaliation_time_run.df %>%
  group_by(data_type) %>%
  summarise_at(vars(time_to_retal), list(avg_time_to_retal = mean))



length(unique(retal_rand_avgs$avg_time_to_retal))

ggplot(retal_rand_avgs2022G2, aes(x=avg_time_to_retal)) + 
  geom_histogram(aes(y=..density..),      
                 binwidth=10,
                 colour="black", fill="white") +
  geom_density() +   scale_x_continuous(name = "length in s of mean retal events random vs mean observed", limits = c(0,1000)) +
  geom_vline(xintercept = retal_length_ready_avg2022G2, colour = "red", size = 2)


retal_tally2022G2 <-length(which(retal_rand_avgs2022G2$avg_time_to_retal < retal_length_ready_avg2022G2))

pretal_tally2022G2 <-  retal_tally2022G2/length(retal_rand_avgs2022G2$avg_time_to_retal)



```