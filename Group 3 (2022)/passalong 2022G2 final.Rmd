---
title: "passalong 2022G2"
author: "Xavier Francis"
date: "2024-03-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

---
title: "passalong 2022G2 final"
author: "Xavier Francis"
date: "2024-03-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Load packages
```{r}
library(readr)
library(dplyr)
library(tidyr)
library(data.table) 
library(ggplot2)
library(chemodiv)
library(introdataviz)
library(lme4)
library(multcomp)
library(sjPlot)
library(emdist)


```


#count of rule follows
```{r}
#start with both_numbered_sorted2022G2

#ensure that ranks are numeric
both_numbered_sorted2022G2$actor_rank <- as.numeric(both_numbered_sorted2022G2$actor_rank)
both_numbered_sorted2022G2$subject_rank <- as.numeric(both_numbered_sorted2022G2$subject_rank)

head(both_numbered_sorted2022G2)


#procedure to add obs session

#store the first row as a separate df. It will be binded back on later 
row_1_obs <- both_numbered_sorted2022G2[1,]

#put events side by side. This will allow us to subtract consecutive times from one another to determine whether an event took place on a separate observation session. 
obs_period_pt_1 <- mutate(both_numbered_sorted2022G2, actor_2 = lead(actor),
actor_2_rank = lead(actor_rank), 
subject_2 = lead(subject),                                   
subject_2_rank = lead(subject_rank), 
 full_time_2 = lead(full_time), 
date2 = lead(date))

#add empty columns for observation period and date period
obs_period_pt_1$obs_period <- NA
obs_period_pt_1$date_period <- NA

#create ticker for loop
q <- 1

#loop to calculate observation sessions. If consecutive events were on the same day but there was a long time between events, it is determined that the 2nd event took place in a separate observation session. The ticker goes up, and is reset if events took place on different days.
for (i in 1:nrow(obs_period_pt_1)) {ifelse(obs_period_pt_1$date[i] == obs_period_pt_1$date2[i]
                                            & obs_period_pt_1$full_time_2[i] - obs_period_pt_1$full_time[i] >= 1800, q <- q+1, q <- q)
  ifelse(obs_period_pt_1$date[i] != obs_period_pt_1$date2[i], q <- 1, q <- q)
  obs_period_pt_1$obs_period [i] <- q
  }

#remove original columns and keep mutated columns. These will replace original columns
obs_period_pt_2 <- subset(obs_period_pt_1, select = c(date2,  full_time_2, actor_2, actor_2_rank, subject_2, subject_2_rank, obs_period, date_period  ))

#get rid of the bottom, which will be full of NAs, as the last event in the original data does not have anything that comes after
obs_period_pt_3 <- slice(obs_period_pt_2, 1:(n() - 1))

#rename mutated columns with original names 
setnames(obs_period_pt_3, old = c('date2',  'full_time_2', 'actor_2', 'actor_2_rank', 'subject_2', 'subject_2_rank'), 
         new = c('date',  'full_time', 'actor', 'actor_rank', 'subject', 'subject_rank'))

#add observation period "1" onto first row that we subseted off, as the first event in the data has to take place in obs session 1
row_1_obs$obs_period <- 1 
row_1_obs$date_period <- NA

#ensure that row 1 matches the df
row_1_obs_ready <-  subset(row_1_obs, select = c(date,  full_time, actor, actor_rank, subject, subject_rank, obs_period, date_period  ))

#bind first row and df together
obs_period_pt_4 <- rbind(row_1_obs_ready, obs_period_pt_3)
#add date period 
obs_period_pt_4$date_period <- paste(obs_period_pt_4$date,obs_period_pt_4$obs_period)
head(obs_period_pt_4)



date_x <- obs_period_pt_4$date
obs <- obs_period_pt_4$date_period
#separate data into a list with each df=a date so we can randomize within days
#sort_by_date <- function(x, i, y) {y <- filter(x, date == i )
#mutate(y, date_counter = i)}


#list of dataframes where each dataframe has a certain birdname isolated as actor or recipient
pass_along_aggression_list_2022G2 <- list()


dater <- unique(obs)
datex <- c(1: length(unique(obs)))
actorer <- actor
actex <- c(1:length(actor))




#separate data into list of each obs session each day for each bird
for(i in datex) { 
  for (g in actex){
    output <- filter(obs_period_pt_4, obs_period_pt_4$date_period == dater[i] & (subject == actorer[g] | actor == actorer[g]))
    if (nrow(output) < 1) {output [ nrow(output) + 1 , ] <- NA
    } 
    output <- mutate(output, counter = actorer[g])
    pass_along_aggression_list_2022G2[[paste0("list", dater[i], actorer[g])]] <- output}}





#ensure df arranged by date and time
pass_along_aggression_list_2022G2 <- lapply(pass_along_aggression_list_2022G2, function(x) arrange(x, date, full_time))





#modified data frame to put consecutive events side by side

pass_along_side_by_side <- lapply(pass_along_aggression_list_2022G2, function(x) mutate(x, actor_2 = lead(actor), 
                                                                                 actor_2_rank = lead(actor_rank), 
                                                                                 subject_2 = lead(subject), 
                                                                                 subject_2_rank = lead(subject_rank), 
                                                                                 full_time_2 = lead(full_time), 
                                                                                 date2 = lead(date))) 


dateact1 <-  c(1:length(pass_along_side_by_side))


#pick out pass along rule while keeping all dataframes in a list (yay!!!)
for(i in dateact1 ) {
  pass_along_side_by_side[[i]] <- mutate(pass_along_side_by_side[[i]], 
                                         initiated = ifelse(subject == counter, "yes","no"), 
                                         rule_followed = ifelse( subject == actor_2 
                                                                 & full_time_2 - full_time <= 336 
                                                                 & full_time_2 - full_time > 0
                                                                 & date2 == date
                                                                 & subject == counter
                                                                 & actor_2 == counter
                                                                 & actor_2_rank < subject_2_rank
                                                                 & actor != subject_2,
                                                                 "yes","no"))
} 




#combine dataframes into one huge dataframe
pass_along_huge <- bind_rows(pass_along_side_by_side, .id = "column_label")

#sort by time and date
pass_along_huge_sorted <- pass_along_huge %>%
  arrange(pass_along_huge$date, pass_along_huge$full_time)

#Remove duplicate events, events that have been represented twice, and events that could not confidently be counted as the start of passalong
pass_along_huge_sorted_no_dupr <- subset(pass_along_huge_sorted, initiated != "no") 

#subset for desired columns
pass_along_no_dupr <- subset(pass_along_huge_sorted_no_dupr, select = c(date, full_time, actor, actor_rank, subject, subject_rank,  
                                                                        counter, actor_2, actor_2_rank, subject_2, subject_2_rank, full_time_2, date2, 
                                                                        initiated, rule_followed))

table(pass_along_no_dupr$rule_followed)

#detemine how many times pass-along was followed
pass_along_real_2022G2 <- length(which(pass_along_no_dupr$rule_followed == "yes"))


pass_along_real_2022G2_frame <- data.frame(pass_along_real_2022G2)

#create df of only follows
pass_along_doner_all_yes <-filter(pass_along_no_dupr, rule_followed == "yes")



```

#individ rule use
```{r}


#test for individual use of rule. How many times did each bird use rule
unique(pass_along_doner_all_yes$actor_2)
length(unique(pass_along_doner_all_yes$actor_2)
)

summary.pass.individ_2022G2 <- pass_along_doner_all_yes %>% group_by(actor_2) %>%
  dplyr::summarize (
    count =n())

summary.pass.individ_2022G2



#show Liz
#unique(`2022G2_interactions_cleaned`$actor)

#compare to raw dataset to see if any birds didnt use rule at all
unique(t2022_aggression_onlyG2$actor)
unique(t2022_aggression_onlyG2$subject)

setdiff(bird.list, unique(t2022_aggression_onlyG2$subject) )

#for each rule keep in mind how many birds can actually use the rule
#bird who didnt do rule was bottom ranked and cant do rule

pass_along_nofollow <- setdiff(unique(t2022_aggression_onlyG2$actor), unique(pass_along_doner_all_yes$actor_2)
)
pass_along_nofollow
#Calculate Richness score for rule following
#DO FIRST BEFORE ADDING ZEROS AND DONT DO AGAIN WITHOUT RUNNING ABOVE CODE
pass_along_richness <- length(summary.pass.individ_2022G2$actor_2)/18




pass_along_zeros <- rep(c(0),times=c(length(pass_along_nofollow)))


pass_along_nofollow_zeros<- data.frame(pass_along_nofollow,pass_along_zeros) 

colnames(pass_along_nofollow_zeros) <- c("actor_2","count")

summary.pass.individ_2022G2 <- rbind(summary.pass.individ_2022G2, pass_along_nofollow_zeros)


# Plot
individ_pass_plot_2022G2 <- ggplot(summary.pass.individ_2022G2, aes(x = actor_2, y = count )) + 
  geom_bar(stat = "identity", width = 0.6) + # Consistent bar width
scale_y_continuous( breaks = seq(0, 60, 2)) + 
  theme_minimal()  +
  theme(
    axis.text.x = element_text(angle = 90, vjust=0.5),
    axis.title.x = element_text( face = "bold",  margin = margin(t = 15)),  # X-axis title
    axis.title.y = element_text( face = "bold",  margin = margin(r = 15)),
    ) +
  labs(
    x = "Parakeet ID",  # Add your custom x-axis title here
    y = "Count of rule follows"   # Add your custom y-axis title here
  )

individ_pass_plot_2022G2
#Calculate eveness metric
pass_for_even <- subset(summary.pass.individ_2022G2, select = c(count))

final_pass_for_even <- as.data.frame(t(pass_for_even))

pass_even_value <-calcDiv(final_pass_for_even, type = "PielouEven", q = 1) 

pass_even_value

```

#rule speed
```{r}


########################################################################################################
#test for length of passalong

#follows similar procedure as calculating the count of rule follows, with some differences in the rule detection loop and the structure

#put df side by side
pass_along_side_by_side_time <- lapply(pass_along_aggression_list_2022G2, function(x) mutate(x, actor_2 = lead(actor), 
                                                                                      actor_2_rank = lead(actor_rank), 
                                                                                      subject_2 = lead(subject), 
                                                                                      subject_2_rank = lead(subject_rank), 
                                                                                      full_time_2 = lead(full_time), 
                                                                                      date2 = lead(date))) 






#test for length of pass-alongs in seconds
for(i in dateact1) {
  pass_along_side_by_side_time[[i]] <- mutate(pass_along_side_by_side_time[[i]], 
                                              initiated = ifelse(subject == counter, "yes","no"), 
                                              rule_followed = ifelse( subject == actor_2 
                                                                      & date2 == date
                                                                      & subject == counter
                                                                      & actor_2 == counter
                                                                      & actor_2_rank < subject_2_rank
                                                                      & full_time_2 - full_time > 0
                                                                      & actor != subject_2,
                                                                      "yes","no"),
                                              time_to_pass = full_time_2 - full_time)
} 

#bind list of dfs into one df
pass_along_huge_time <- bind_rows(pass_along_side_by_side_time, .id = "column_label")

#sort by time and date
pass_along_huge_sorted_time <- pass_along_huge_time %>%
  arrange(pass_along_huge_time$date, pass_along_huge_time$full_time)


#remove any duplicate or double counted events 
pass_along_huge_sorted_no_dupr_time <- subset(pass_along_huge_sorted_time, initiated != "no") 

#subset for columns of interest
pass_along_no_dupr_time <- subset(pass_along_huge_sorted_no_dupr_time, select = c(date, full_time, actor, actor_rank, subject, subject_rank,  
                                                                                  counter, actor_2, actor_2_rank, subject_2, subject_2_rank, full_time_2, date2, 
                                                                                  initiated, rule_followed, time_to_pass,date_period))


#get df where rule was followed
pass_length <- subset(pass_along_no_dupr_time, rule_followed != "no")

#subset for columns of interest
pass_length_ready_2022G2 <- subset( pass_length, select = c(time_to_pass, actor, subject, actor_2,subject_2, date_period))

p <- length(pass_length_ready_2022G2$time_to_pass)

#summarize the speed of rule follows. Here we are checking whether the speed of the rule in question tends to be clustered
summary.pass <- pass_length_ready_2022G2 %>% group_by(time_to_pass) %>%
  dplyr::summarize (
    count =n())


summary.pass

#quick glimpses of the distribution of rule speeds
ggplot(pass_length_ready_2022G2, aes(x=time_to_pass)) + 
  geom_histogram(aes(y=..density..),      
                 binwidth=50,
                 colour="black", fill="white") + 
  geom_density()




ggplot(pass_length_ready_2022G2, aes(x=time_to_pass)) + 
  geom_histogram(aes(y=..density..),      
                 binwidth=10,
                 colour="black", fill="white") + 
  geom_density() +   scale_x_continuous(name = "length in s of pass along events", limits = c(0,3000)) 



#
#here im calculating the mean time between events when looking at interactions focal birds were involved in for all the birds 

time_between_events2022G2 <- subset(pass_along_huge_sorted_time, select = c(time_to_pass))
time_between_events2022G2$time_to_pass <- as.numeric(time_between_events2022G2$time_to_pass)

mean_time_between_events2022G2 <- mean(time_between_events2022G2$time_to_pass, na.rm=TRUE)




```
# Permutation to randomize order of events
```{r}

#################################################loop#################################################################

#start with "both_numbered_sorted2022G2"

head(both_numbered_sorted2022G2)


#procedure to randomize within obs sesh
#store first  row
row_1_obs <- both_numbered_sorted2022G2[1,]

#put events side by side. This will allow us to subtract consecutive times from one another to determine whether an event took place on a separate observation session.
obs_period_pt_1 <- mutate(both_numbered_sorted2022G2, actor_2 = lead(actor),
                          actor_2_rank = lead(actor_rank), 
                          subject_2 = lead(subject),                                   
                          subject_2_rank = lead(subject_rank), 
                          full_time_2 = lead(full_time), 
                          date2 = lead(date))



#add empty columns for observation period and date period
obs_period_pt_1$obs_period <- NA
obs_period_pt_1$date_period <- NA
#create ticker for loop
q <- 1

#loop to calculate observation sessions. If consecutive events were on the same day but there was a long time between events, it is determined that the 2nd event took place in a separate observation session. The ticker goes up, and is reset if events took place on different days.
for (i in 1:nrow(obs_period_pt_1)) {ifelse(obs_period_pt_1$date[i] == obs_period_pt_1$date2[i]
                                            & obs_period_pt_1$full_time_2[i] - obs_period_pt_1$full_time[i] >= 1800, q <- q+1, q <- q)
  ifelse(obs_period_pt_1$date[i] != obs_period_pt_1$date2[i], q <- 1, q <- q)
  obs_period_pt_1$obs_period [i] <- q
  }

#remove original columns and keep mutated columns. These will replace original columns
obs_period_pt_2 <- subset(obs_period_pt_1, select = c(date2,  full_time_2, actor_2, actor_2_rank, subject_2, subject_2_rank, obs_period, date_period  ))

#get rid of the bottom, which will be full of NAs, as the last event in the original data does not have anything that comes after
obs_period_pt_3 <- slice(obs_period_pt_2, 1:(n() - 1))

#rename mutated columns with original names 
setnames(obs_period_pt_3, old = c('date2',  'full_time_2', 'actor_2', 'actor_2_rank', 'subject_2', 'subject_2_rank'), 
         new = c('date',  'full_time', 'actor', 'actor_rank', 'subject', 'subject_rank'))

#add observation period "1" onto first row that we subseted off, as the first event in the data has to take place in obs session 1
row_1_obs$obs_period <- 1 
row_1_obs$date_period <- NA

#ensure that row 1 matches the df
row_1_obs_ready <-  subset(row_1_obs, select = c(date,  full_time, actor, actor_rank, subject, subject_rank, obs_period, date_period  ))

#bind first row and df together
obs_period_pt_4 <- rbind(row_1_obs_ready, obs_period_pt_3)
#add date period 
obs_period_pt_4$date_period <- paste(obs_period_pt_4$date,obs_period_pt_4$obs_period)



obs <- obs_period_pt_4$date_period
#separate data into a list with each df=a date period so we can randomize within days and obs periods

datelist <- list()
dater <- unique(obs)
datex <- c(1: length(unique(obs)))

#loop to create a separate dataframe for of each obs session each day 
#Each dataframe is stored within a list to make the dataframes easy to work with
#We wish to conserve our permutation randomization within days and, more specifically, within observation sessions
for(i in datex) { 
  output <- filter(obs_period_pt_4, obs_period_pt_4$date_period == dater[i] )
   if (nrow(output) < 1) {output [ nrow(output) + 1 , ] <- NA
    } 
      datelist[[paste0("list", dater[i])]] <- output}




#run ids should be 1 through however many times you want to run through the permutation. Here 1000 times
masterframe_passalong_2022G2.df <- data.frame(runIDs = character(),
                                       actor = character(),
                                       subject = character(),
                                       date = character(),
                                       full_time = integer(),
                                       counter = character(),
                                       actor_2 = character(),
                                       subject_2 = character(),
                                       full_time_2 = integer(),
                                       date2 = character(),
                                       initiated = character(),
                                       rule_followed = character(),
                                       stringsAsFactors=FALSE)


nruns <- 1000
pb <- txtProgressBar(min=0, max = nruns, style = 3)
set.seed(601)
#seed for unrestricted = 287
#seed for 8 sec = 3
#seed for 85 sec = 987
#seed for 336 = 601
#forloop starts here'
for (r in 1:length(runIDs)) { #r = 1 is a test you can uncomment to see if it works before #running it 100 times
  #r = 1
  run <- r
setTxtProgressBar(pb, r) #update progress bar
  
  loop.run <- paste("run", run) 
  loop.run
  #for example, if r = 1, looprun will say run 1 which will allow you to keep each run's #data straight
  
  
  #loop.seed <- set.seed[r] didnt work so ignore. not needed
  
  
 #renamed data
  loop.datalist <- datelist
  head(loop.datalist[[3]])
 xorder <- c()
  listlength <- as.numeric(length(loop.datalist))
  datex2 <- 1:listlength
  full_time_list <-c()
  loop.data.randomized.time.added <- c()
  #get rid of anything thats not actor and receiver (we will bind back on the date and time #later anyways to preserve
  #their order)
  


   for(i in datex2) {
     #store time
     full_time_list[[i]] <- subset(loop.datalist[[i]], select = c(full_time))
     #remove time from each df in the list. randomizing the order of time wouldnt make sense
     loop.datalist[[i]] <- subset(loop.datalist[[i]], select = -c(full_time))

      #create a randomized sequence of numbers to bind to the subset data (ex. 2,6,1,3,5,4)
      #sort the data frame to put the randomized numbers in order from 1 to whatever and voila, the order of events has been randomized (ex.  from above 1,2,3,4,5,6)
    xorder[[i]] <- data.frame(xorder = sample(1:length(loop.datalist[[i]]$actor),
                                              length(loop.datalist[[i]]$actor)))
    #bind random order to df
    loop.datalist[[i]] <- mutate(loop.datalist[[i]], 
                                 xorderx = xorder[[i]]$xorder)
    #put randomized order of numbers in order to randomize rows in the dataset
    loop.datalist[[i]] <-
      loop.datalist[[i]][order(loop.datalist[[i]]$xorderx),]
    #bind time back on
    loop.data.randomized.time.added[[i]] <- bind_cols(loop.datalist[[i]], full_time_list[[i]])
    loop.data.randomized.time.added[[i]] <- subset(loop.data.randomized.time.added[[i]], select = -c(xorderx))

   }

  
#separate data into list of each obs session each day for each bird
actorer <- actor
actex <- c(1:length(actor))
dater <- unique(obs)
list_split_by_bird <- c()

for(i in datex2) {
for (g in actex) {output <- subset(loop.data.randomized.time.added[[i]], actor == actorer[g] |  subject == actorer[g])
   if (nrow(output) < 1) {output [ nrow(output) + 1 , ] <- NA
    } 
  output <- mutate(output, counter = actorer[g])
  list_split_by_bird[[paste0("list", dater[i], actorer[g])]] <- output
}}

 
  #arrange by time and date
list_split_by_bird <- lapply(list_split_by_bird, function(x) arrange(x, date, full_time))

  
  #rename df
 pass_along_aggression_list <- list_split_by_bird

  
  
  
  #modified each data frame to put consecutive events side by side
  pass_along_side_by_side <- lapply(pass_along_aggression_list, function(x) mutate(x, actor_2 = lead(actor), 
                                                                                   actor_2_rank = lead(actor_rank), 
                                                                                   subject_2 = lead(subject), 
                                                                                   subject_2_rank = lead(subject_rank), 
                                                                                   full_time_2 = lead(full_time), 
                                                                                   date2 = lead(date))) 
  
  
  
  
  
  
  head(pass_along_side_by_side[["1"]])
  
  
  #pick out pass along rule while keeping all dataframes in a list (yay!!!)
  for(i in dateact1) {
    pass_along_side_by_side[[i]] <- mutate(pass_along_side_by_side[[i]], 
                                           initiated = ifelse(subject == counter, "yes","no"), 
                                           rule_followed = ifelse( subject == actor_2 
                                                                   & full_time_2 - full_time  <= 336 
                                                                   & full_time_2 - full_time > 0
                                                                   & date2 == date
                                                                   & subject == counter
                                                                   & actor_2 == counter
                                                                   & actor_2_rank < subject_2_rank
                                                                   & actor != subject_2,
                                                                   "yes","no"))
  } 
  
  
  
  
  #combine dataframes into one huge dataframe
  pass_along_huge <- bind_rows(pass_along_side_by_side, .id = "column_label")
  
  #sort by time and date
  pass_along_huge_sorted <- pass_along_huge %>%
    arrange(pass_along_huge$date, pass_along_huge$full_time)
  
  
  #need to check but i think it works to get rid of all "initiated no" rows to get rid of duplicates, as pass along 
  #is literally possible whenever an aggressive event takes place
  
  pass_along_huge_sorted_no_dup <- subset(pass_along_huge_sorted, initiated != "no") 
  
  pass_along_no_dup <- subset(pass_along_huge_sorted_no_dup, select =  c(actor, actor_rank, subject, subject_rank, date, full_time, 
                                                                         counter, actor_2, actor_2_rank, subject_2, 
                                                                         subject_2_rank, full_time_2, date2, 
                                                                         initiated, rule_followed))
  
  runIDs <- rep(loop.run, length(pass_along_no_dup$actor))
  
  passalong_complete <- cbind(runIDs, pass_along_no_dup)
  
  masterframe_passalong_2022G2.df  <- rbind(masterframe_passalong_2022G2.df, passalong_complete)
}

#######################################################LOOP#END#######################################################
#write.csv(masterframe_passalong_2022G2.df, "C:/Users/Xmanf/Desktop/Ch1 TDR files/passalong2022G2countmaster_336sec.csv")

```


#rule follows vs random
```{r}


#masterframe_passalong_2022G2.df <- read.csv("C:/Users/Xmanf/Desktop/Ch1 TDR files/passalong2022G2countmaster_336sec.csv", header=TRUE, stringsAsFactors=FALSE)


#put run #s in an ascending vector
#create vector for number of time the rules were followed to be stored
cum_run_IDS <- unique(masterframe_passalong_2022G2.df$runIDs)
random_times_pass_along_followed <- c()


#put the number of times the rule was followed into one vector for analysis 
for (j in cum_run_IDS) {
  len_of_passalongs <- length(which(masterframe_passalong_2022G2.df$rule_followed == "yes" & 
                                      masterframe_passalong_2022G2.df$runIDs == j))
  
  random_times_pass_along_followed <- c(random_times_pass_along_followed, len_of_passalongs)
}


rand_pass_.frame_2022G2 <- data.frame(random_times_pass_along_followed)


 pass_2022G2_count_plot <- ggplot(rand_pass_.frame_2022G2, aes(x=random_times_pass_along_followed)) + 
  geom_histogram(aes(y=..density..),      
                 binwidth=6,
                 colour="black", fill="grey") +
  geom_density() + 
  geom_vline(xintercept = pass_along_real_2022G2, colour = "red", size = 2) + geom_density(lwd = 1, linetype = 1) + theme_minimal() + theme(axis.text = element_text(size=25),  axis.title= element_blank()) +
  scale_x_continuous(name = "Count of Pass-along events", breaks=seq(0, 400, 100)) +  
     coord_cartesian(xlim = c(0, 400), ylim = c(0,.04)) +
scale_y_continuous(breaks = seq(0, .04, .01)) 

pass_2022G2_count_plot


#calculate p value (proportion of randomized reference values that are more "extreme" than the observed count of rule follows)
pass_tally2022G2 <-length(which(rand_pass_.frame_2022G2$random_times_pass_along_followed > pass_along_real_2022G2))

finalpass_tally2022G2 <- 1 - pass_tally2022G2/length(rand_pass_.frame_2022G2$random_times_pass_along_followed)




#p = 0 for unrestricted
#p = .148 for 8 sec
#p = 0 for 85 sec
#p = 0 for 336
```

#randomize rule speed
```{r}
#Here we are randomizing time between events for the permutation
#start with 
head(pass_along_aggression_list[[1]])


#randomize time between initiation and response between events

pass_along_side_by_side_time <- lapply(pass_along_aggression_list_2022G2, function(x) mutate(x, actor_2 = lead(actor), 
                                                                                      actor_2_rank = lead(actor_rank), 
                                                                                      subject_2 = lead(subject), 
                                                                                      subject_2_rank = lead(subject_rank), 
                                                                                      full_time_2 = lead(full_time), 
                                                                                      date2 = lead(date))) 






#Loop to detect instances and speed of rule use for the rule in question 
for(i in dateact1) {
  pass_along_side_by_side_time[[i]] <- mutate(pass_along_side_by_side_time[[i]], 
                                              initiated = ifelse(subject == counter, "yes","no"), 
                                              rule_followed = ifelse( subject == actor_2 
                                                                      & date2 == date
                                                                      & subject == counter
                                                                      & actor_2 == counter
                                                                      & actor_2_rank < subject_2_rank
                                                                      & full_time_2 - full_time > 0
                                                                      & actor != subject_2,
                                                                      "yes","no"),
                                              time_to_pass = full_time_2 - full_time)
} 

pass_along_huge_time <- bind_rows(pass_along_side_by_side_time, .id = "column_label")





#Remove duplicate and double counted sequences
pass_along_huge_time <- distinct(pass_along_huge_time, date, full_time, actor, actor_rank, subject, subject_rank, obs_period, date_period, actor_2, subject_2, full_time_2, date2, time_to_pass, .keep_all= TRUE) 


#remove instances of rule use whos speed were calculated to be 0. In this case we cant be certain of which event actually came first
pass_along_huge_time <- filter(pass_along_huge_time, time_to_pass != 0)


date_x <- pass_along_huge_time$date
obs <- pass_along_huge_time$date_period
#separate data into a list with each df=a date so we can randomize within days
#sort_by_date <- function(x, i, y) {y <- filter(x, date == i )
#mutate(y, date_counter = i)}

rule_time_ready_for_rand_list <- list()
dater <- unique(obs)
datex <- c(1: length(unique(obs)))

#loop to create a separate dataframe for each bird that only contains interactions #pertaining to that bird.
#Each dataframe is stored within a list to make the dataframes easy to work with
#separate data into list of each obs session each day 
for(i in datex) { 
  output <- filter(pass_along_huge_time, pass_along_huge_time$date_period == dater[i] )
   if (nrow(output) < 1) {output [ nrow(output) + 1 , ] <- NA
    } 
      rule_time_ready_for_rand_list[[paste0("list", dater[i])]] <- output}









nruns <- 1000

pb = txtProgressBar(min=0, max = nruns, style = 3)

#run ids should be 1 through however many times you want to run through the permutation
runIDs <- seq(1,1000)

#create an empty masterframe to be filled with each run of the permutation
masterframe_passalong.df_time_2022G2 <- data.frame(runIDs = character(),
                             actor = character(),
                             subject = character(),
                             date = character(),
                             full_time = integer(),
                             counter = character(),
                             actor_2 = character(),
                             subject_2 = character(),
                             full_time_2 = integer(),
                             date2 = character(),
                             initiated = character(),
                             rule_followed = character(),
                             time_to_pass = integer(),
                             date_period = character(),
                             stringsAsFactors=FALSE)


set.seed(507)
#forloop starts here'
for (r in 1:length(runIDs)) { #r = 1 is a test you can uncomment to see if it works before #running it 100 times
#r = 1
  run <- r
      setTxtProgressBar(pb, r) #update progress bar
  loop.run <- paste("run", run) 
  loop.run
  #for example, if r = 1, looprun will say run 1 which will allow you to keep each run's #data straight
  
    

  
  #renamed data
  loop.datalist <- rule_time_ready_for_rand_list
    head(loop.datalist[[3]])
    xorder <- c()
  listlength <- as.numeric(length(loop.datalist))
datex2 <- 1:listlength
  full_time_to_rule <-c()
  loop.data.randomized.time_to_rule.added <- c()
    
    

    for(i in datex2) {
         #store time
     full_time_to_rule[[i]] <- subset(loop.datalist[[i]], select = c(time_to_pass))     
     #remove time from each df in the list. randomizing the order of time wouldnt make sense
     loop.datalist[[i]] <- subset(loop.datalist[[i]], select = -c(time_to_pass))
      #create a randomized sequence of numbers to bind to the subset data (ex. 2,6,1,3,5,4)
      #sort the data frame to put the randomized numbers in order from 1 to whatever and voila, the time between events (speed) has been  randomized (ex. from above 1,2,3,4,5,6)
    xorder[[i]] <- data.frame(xorder = sample(1:length(full_time_to_rule[[i]]$time_to_pass),
                                              length(full_time_to_rule[[i]]$time_to_pass)))
    #bind random order to df
    full_time_to_rule[[i]] <- mutate(full_time_to_rule[[i]], 
                                 xorderx = xorder[[i]]$xorder)
    #put randomized order of numbers in order to randomize speed in the dataset
    full_time_to_rule[[i]] <-
      full_time_to_rule[[i]][order(full_time_to_rule[[i]]$xorderx),]
    #bind time back on
    loop.data.randomized.time_to_rule.added[[i]] <- bind_cols(loop.datalist[[i]], full_time_to_rule[[i]])
    loop.data.randomized.time_to_rule.added[[i]] <- subset(loop.data.randomized.time_to_rule.added[[i]], select = -c(xorderx))

   }
  
  
 

#combine dataframes into one huge dataframe
loop.datalist_time_randomized_binded_tested_pass_2022G2 <- bind_rows(loop.data.randomized.time_to_rule.added, .id = "column_label")

#sort by time and date
loop.datalist_time_randomized_binded_tested_pass_2022G2 <- loop.datalist_time_randomized_binded_tested_pass_2022G2 %>%
  arrange(loop.datalist_time_randomized_binded_tested_pass_2022G2$date, loop.datalist_time_randomized_binded_tested_pass_2022G2$full_time)






#Remove duplicate events, events that have been represented twice, and events that could not confidently be counted as the start of passalong
testhugesorted_no_dup_rand_time <- subset(loop.datalist_time_randomized_binded_tested_pass_2022G2, initiated != "no") 

passalong_no_dup_rand_time <- subset(testhugesorted_no_dup_rand_time, select = c(date, full_time, actor, subject, 
                                                               counter, actor_2, subject_2, full_time_2, date2, 
                                                               initiated,  rule_followed,time_to_pass, date_period))





  
  #end of passalong process
  #end of rule code
  
  
  
  #bind vector of run IDs for each run to the dataframe so that you can have a numeric run #id next to each data point
  #that coresponds with that run which will allow you to sort/put them in ascending order later
 runIDs <- rep(loop.run, length(passalong_no_dup_rand_time$actor))
 
  passalong_complete_rand_time_2022G2 <- cbind(runIDs, passalong_no_dup_rand_time)
  
  
#put each runs data into teh masterframe
  masterframe_passalong.df_time_2022G2 <- rbind(masterframe_passalong.df_time_2022G2, passalong_complete_rand_time_2022G2)
  
}


#write.csv(masterframe_passalong.df_time_2022G2, "C:/Users/Xmanf/Desktop/Ch1 TDR files/passalong2022G2timemaster.csv")


```




#rule speed vs random
```{r}

#masterframe_passalong.df_time_2022G2 <- read.csv("C:/Users/Xmanf/Desktop/Ch1 TDR files/passalong2022G2timemaster.csv")


head(masterframe_passalong.df_time_2022G2)

#subset masterframe so that only rule follows are included
masterframe_passalong.df_time_2022G2_only_follows <- subset(masterframe_passalong.df_time_2022G2, rule_followed == "yes" )

#isolate time it takes to carry out rule...
masterframe_passalong_time_sub.df_2022G2 <- subset( masterframe_passalong.df_time_2022G2_only_follows, select = c(actor, subject, actor_2,subject_2, time_to_pass,date_period))
head(masterframe_passalong_time_sub.df_2022G2)



#add data label for the randomized rule speed
masterframe_passalong_time_ready.df <- mutate(masterframe_passalong_time_sub.df_2022G2, data_type = "randomized")

#ensure that time is numeric
masterframe_passalong_time_ready.df$time_to_pass <- as.numeric(masterframe_passalong_time_ready.df$time_to_pass)


head(pass_length_ready_2022G2)

#add data label for the observed rule speed
pass_length_ready_2022G2_label <- mutate(pass_length_ready_2022G2, data_type = "observed")


#combine df for observed rule speed and randomized rule speed into one df
pass_length_ready_2022G2_comb <- rbind(masterframe_passalong_time_ready.df, pass_length_ready_2022G2_label )
unique(pass_length_ready_2022G2_comb$data_type)




#provide label for rule in question
pass_length_ready_2022G2_comb <- mutate(pass_length_ready_2022G2_comb, rule = "passalong")


#make sure that rule speed is numeric
pass_length_ready_2022G2_comb$time_to_pass <- as.numeric(pass_length_ready_2022G2_comb$time_to_pass)


#observed vs randomized raw plot. quick look at how the distriubtuions compare
ggplot(pass_length_ready_2022G2_comb, aes(x=time_to_pass, fill = data_type)) + 
  geom_histogram(aes(y=..density..),      
                 binwidth=1) +#,
                 #colour="black", fill="white") + 
  geom_density() +   scale_x_continuous(name = "length in s of pass events random vs observed", limits = c(0,300)) 


#obtain mode of observed and randomized rule speed for plotting purposes
#getmode <- function(v) {
   #uniqv <- unique(v)
   #uniqv[which.max(tabulate(match(v, uniqv)))]
#}

#pass_2022G2_mode_obs <- getmode(pass_length_ready_2022G2_label$time_to_pass)

#pass_2022G2_mode_rand <-getmode(masterframe_passalong_time_ready.df$time_to_pass)

#bind mode to dfs
#pass_2022G2_mode <-  rbind(pass_2022G2_mode_obs,pass_2022G2_mode_rand)

#test for homogeneity of variance
leveneTest(time_to_pass ~ data_type, data = pass_length_ready_2022G2_comb)


#split violin plot of observed vs randomized rule speed
pass_violin_plot <- ggplot(pass_length_ready_2022G2_comb, aes(rule, time_to_pass, fill = data_type))  +
  introdataviz::geom_split_violin(alpha= .9, trim = TRUE, show.legend = FALSE) +
  geom_boxplot(width = .2, alpha = .2, fatten = 2, show.legend = FALSE, outlier.shape = NA) +
  #stat_summary(fun = "mean", geom = "point",  colour = "darkblue", show.legend = F, 
               #position = position_dodge(.200))  +
  scale_x_discrete(name = "Time Dependent Rule") +  
     coord_cartesian(ylim = c(0, 1000)) +
  scale_y_continuous(name = "Speed of passalong events (s)",
                     breaks = seq(0, 1000, 200) 
                     ) + scale_fill_manual(values=c("red","gray")) +
  theme_minimal(base_size = 20)  + theme(axis.text.y = element_text(size=25), axis.title= element_blank(), axis.text.x = element_blank())


pass_2022G2_time_plot <- pass_violin_plot

pass_2022G2_time_plot

#calculate the means for observed and randomized rule speed
mean_obs_rand_passalong_2022G2 <- pass_length_ready_2022G2_comb %>% group_by(data_type) %>%
  dplyr::summarize (mean(time_to_pass))



mean_obs_rand_passalong_2022G2
#obs 266.7078
#rand 238.6837











#linear mixed model to compare means of observed vs randomized rule speed

m1pass_2022G2 <- glmer(time_to_pass ~ data_type  + (1 | date_period) , data = pass_length_ready_2022G2_comb ,   control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun=2e5)), family = Gamma(link = "log"))
summary(m1pass_2022G2)
#p = 0.00249 
#UPDATE MANU

#find confience intervals
confint_pass_2022G2 <- round(confint(m1pass_2022G2, method = "Wald", level = 0.95), 3)
confint_pass_2022G2
#tukey
summary(glht(m1pass_2022G2, linfct = mcp(data_type="Tukey")), test = adjusted("none"))
#find R2 values
tab_model(m1pass_2022G2)

```

```{r}

#ensure that observed rule speed is numeric
pass_length_ready_2022G2$time_to_pass <- as.numeric(pass_length_ready_2022G2$time_to_pass)


head(pass_length_ready_2022G2)

#convert to a density matrix
#summarize the count of various rule speeds

summary.pass_length_ready_2022G2 <- pass_length_ready_2022G2 %>% group_by(time_to_pass) %>%
  dplyr::summarize (
    count =n())

summary.pass_length_ready_2022G2
#Add density column
summary.pass_length_ready_2022G2_density <- mutate(summary.pass_length_ready_2022G2, density = count/sum(count))
#remove count column
summary.pass_length_ready_2022G2_density_no_count <- subset(summary.pass_length_ready_2022G2_density, select = -c(count))
#reorder the columns
summary.pass_length_ready_2022G2_density_no_count_reordered <- summary.pass_length_ready_2022G2_density_no_count[, c(2, 1)]
head(summary.pass_length_ready_2022G2_density_no_count_reordered)
#convert to matrix
summary.pass_length_ready_2022G2_density_no_count_reordered_mat <- as.matrix(summary.pass_length_ready_2022G2_density_no_count_reordered)





masterframe_length_ready <- subset(masterframe_passalong_time_sub.df_2022G2, select = c(time_to_pass))
head(masterframe_length_ready)

#convert to a density matrix
#summarize the count of various rule speeds

summary.masterframe_length_ready <- masterframe_length_ready %>% group_by(time_to_pass) %>%
  dplyr::summarize (
    count =n())

summary.masterframe_length_ready

#Adddensity column
summary.masterframe_length_ready_density <- mutate(summary.masterframe_length_ready, density = count/sum(count))
#remove count column
summary.masterframe_length_ready_density_no_count <- subset(summary.masterframe_length_ready_density, select = -c(count))
#reorder the columns
summary.masterframe_length_ready_density_no_count_reordered <- summary.masterframe_length_ready_density_no_count[, c(2, 1)]
head(summary.masterframe_length_ready_density_no_count_reordered)
#convert to matrix
summary.masterframe_length_ready_density_no_count_reordered_mat <- as.matrix(summary.masterframe_length_ready_density_no_count_reordered)


#Calculate EMD between observed and randomized rule speed
pass_obs_vs_rand_emd <- emdist::emd(summary.pass_length_ready_2022G2_density_no_count_reordered_mat, summary.masterframe_length_ready_density_no_count_reordered_mat)
pass_obs_vs_rand_emd
#30.96368

```
